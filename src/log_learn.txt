――――8.2――――
merge
--squash
判断是否使用--squash选项最根本的标准是，待合并分支上的历史是否有意义。
如果在开发分支上提交非常随意，甚至写成微博体，那么一定要使用--squash选项。版本历史记录的应该是代码的发展，而不是开发者在编码时的活动。
只有在开发分支上每个commit都有其独自存在的意义，并且能够编译通过的情况下（能够通过测试就更完美了），才应该选择缺省的合并方式来保留commit历史。
--no-ff
Git merge --no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态

关于处理设置gitignore之前就push了的文件的问题
――――
正确的做法应该是：git rm --cached logs/xx.log，然后更新 .gitignore 忽略掉目标文件，最后 git commit -m "We really don't want Git to track this anymore!"

对于一些每个开发者内容都可能不一样但需要在库中有一个模板的文件
――――
对于充当模版的文件，在文件名上加以区分然后用 Git 记住。比如说实际的配置文件应该叫 database.conf，在写好模版之后可以更名为 database.conf.example。Git 记录 database.conf.example 但是忽略 database.conf。
每一个人克隆下来之后，复制一份 database.conf.example 为 database.conf 然后修改后者以符合本地的要求。由于后者是在 .gitignore 里的，所以不会被记录，也完全不需要 update-index。
或者另一种办法为 在项目根路径下写一个初始化脚本，第一次 _clone_ 回来之后运行一下初始化脚本在你的本地生成一些必须要有的文件（但是不如版本控制系统）。

――――8.3――――
git中所有文件只有三种状态：已修改，以暂存，已提交
基本的 Git 工作流程如下：
-在工作目录中修改某些文件。 （工作目录――从git目录中的压缩对象数据库中提取出来）
-对修改后的文件进行快照，然后保存到暂存区域。（暂存区域――git目录中的索引文件）
-提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。

git数据库中的文件都是由一个40位的16进制串唯一标识。
git
――objects/：存储压缩后的数据内容 40位串的前两位作为文件夹名字，剩下38位作为文件名存至目录 （gc后的文件存在pack文件夹中？）
――refs/：存储指向数据（分支）的提交对象的指针
――HEAD 指向当前分支
――index 暂存区 一个二进制文件


每个更新的文件都会在本地有一个快照，而并非如同其他系统只关心内容的差异。
当提交更新的时候，git会根据暂存区的信息进行快照，并保存一个指向这次快照的索引。如果文件没有变化，git不会再次保存（以提高性能）
↑SHA-1有文件内容计算hash值，hash值相同，则文件内容相同。其另一用途是检测文件的完整性。
每个git端都一个版本库，所以大部分操作都可以在本地完成。